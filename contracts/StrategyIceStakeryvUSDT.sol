// SPDX-License-Identifier: AGPL-3.0
// Feel free to change the license, but this is what we use

// Feel free to change this version of Solidity. We support >=0.6.0 <0.7.0;
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

// These are the core Yearn libraries
import {
    BaseStrategy,
    StrategyParams
} from "@yearnvaults/contracts/BaseStrategy.sol";
import {
    SafeERC20,
    SafeMath,
    IERC20,
    Address
} from "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";

// Import interfaces for many popular DeFi projects, or add your own!
import {IUniswapV2Router02} from "./interfaces/uniswap.sol";

interface IyVault {
	function deposit() external; // deposit all of our USDT into yvUSDT
}

interface ISorbettiere {
    struct UserInfo {
        uint256 amount; // How many LP tokens the user has provided.
        uint256 rewardDebt; // Reward debt. See explanation below.
        uint256 remainingIceTokenReward; // ICE Tokens that weren't distributed for user per pool.
        //
        // We do some fancy math here. Basically, any point in time, the amount of ICE
        // entitled to a user but is pending to be distributed is:
        //
        //   pending reward = (user.amount * pool.accICEPerShare) - user.rewardDebt
        //
        // Whenever a user deposits or withdraws Staked tokens to a pool. Here's what happens:
        //   1. The pool's `accICEPerShare` (and `lastRewardTime`) gets updated.
        //   2. User receives the pending reward sent to his/her address.
        //   3. User's `amount` gets updated.
        //   4. User's `rewardDebt` gets updated.
    }

    function withdraw(uint256 _pid, uint256 _amount) external;

    function deposit(uint256 _pid, uint256 _amount) external;

    function userInfo(uint256 _pid, address _user)
        external
        view
        returns (UserInfo memory);
        
    function pendingIce(uint256 _pid, address _user)
        external
        view
        returns (uint256);
        
	function emergencyWithdraw(uint256 _pid) public;
}

contract StrategyIceStakeryvUSDT is BaseStrategy {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    uint256 public pid;
    ISorbettiere address public sorbettiere = ISorbettiere(address(0x5F03BD60e6b5Acf744c4Bf48EdB1Cd4f1192dc6D));
    uint256 public manualKeep3rHarvest = 0;
    address public constant uniswapRouter =
        address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    IERC20 public constant usdt =
        IERC20(address(0xdAC17F958D2ee523a2206206994597C13D831ec7));
    IERC20 public constant weth =
        IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));
    IERC20 public constant ice =
        IERC20(address(0xf16e81dce15B08F326220742020379B855B87DF9));
    uint256 public harvestProfitFactor; 

    constructor(address _vault) public BaseStrategy(_vault) {
        // You can set these parameters on deployment to whatever you want
        // maxReportDelay = 6300;
        // profitFactor = 100;
        // debtThreshold = 0;
    }

    function name() external view override returns (string memory) {
        // Add your own name here, suggestion e.g. "StrategyCreamYFI"
        return "StrategyIceStakeryvUSDT";
    }

    function estimatedTotalAssets() public view override returns (uint256) {
    	// assets in the strategy plus any staked assets
        return want.balanceOf(address(this)).add(sorbettiere.userInfo(pid, address(this)).amount);
    }

    function prepareReturn(uint256 _debtOutstanding)
        internal
        override
        returns (
            uint256 _profit,
            uint256 _loss,
            uint256 _debtPayment
        )
    {
        // TODO: Do stuff here to free up any returns back into `want`
        // NOTE: Return `_profit` which is value generated by all positions, priced in `want`
        // NOTE: Should try to free up at least `_debtOutstanding` of underlying position
        
        // Claim any remaining staked ICE
        sorbettiere.deposit(pid, 0);
        uint256 iceBalance = ice.balanceOf(address(this));
        
        // sell this ICE for USDT
        _sell(iceBalance);
        
        // deposit USDT for yvUSDT
        IyVault(want).deposit();
        
        // if this was the result of a manual keep3r harvest, then reset our trigger
        if (manualKeep3rHarvest == 1) manualKeep3rHarvest = 0;
        
        // serious loss should never happen, but if it does (for instance, in the case of a hack), let's record it accurately
        uint256 assets = estimatedTotalAssets();
        uint256 debt = vault.strategies(address(this)).totalDebt;

        // if assets are greater than debt, things are working great!
        if (assets > debt) {
            _profit = want.balanceOf(address(this));
        }
        
        // if assets are less than debt, we are in trouble
        else {
            _loss = debt.sub(assets);
            _profit = 0;
        }

        // debtOustanding will only be > 0 in the event of revoking or lowering debtRatio of a strategy
        if (_debtOutstanding > 0) {
            uint256 stakedBal = sorbettiere.userInfo(pid, address(this)).amount;
            sorbettiere.withdraw(
                pid,
                Math.min(stakedBal, _debtOutstanding)
            );

            _debtPayment = Math.min(
                _debtOutstanding,
                want.balanceOf(address(this))
            );
        }

        return (_profit, _loss, _debtPayment);
        
    }

    // Sells our harvested ICE into USDT
    function _sell(uint256 _amount) internal {
        address[] memory icePath = new address[](3);
        icePath[0] = address(ice);
        icePath[1] = address(weth);
        icePath[2] = address(usdt);
        
        IUniswapV2Router02(uniswapRouter).swapExactTokensForTokens(
            _amount,
            uint256(0),
            icePath,
            address(this),
            now
        );
    }

    function adjustPosition(uint256 _debtOutstanding) internal override {
        // TODO: Do something to invest excess `want` tokens (from the Vault) into your positions
        // NOTE: Try to adjust positions so that `_debtOutstanding` can be freed up on *next* harvest (not immediately)
        if (emergencyExit) {
            return;
        }

        uint256 yvusdtBalance = want.balanceOf(address(this));
        if (yvusdtBalance > 0) {
            sorbettiere.deposit(pid, yvusdtBalance);
        }
    }

    function liquidatePosition(uint256 _amountNeeded)
        internal
        override
        returns (uint256 _liquidatedAmount, uint256 _loss)
    {
        uint256 wantBal = want.balanceOf(address(this));
        if (_amountNeeded > wantBal) {
            uint256 stakedBal = sorbettiere.userInfo(pid, address(this)).amount;
            sorbettiere.withdraw(
                pid,
                Math.min(stakedBal, _amountNeeded - wantBal)
            );
            uint256 withdrawnBal = want.balanceOf(address(this));
            _liquidatedAmount = Math.min(_amountNeeded, withdrawnBal);

            // if _amountNeeded != withdrawnBal, then we have an error
            if (_amountNeeded != withdrawnBal) {
                uint256 assets = estimatedTotalAssets();
                uint256 debt = vault.strategies(address(this)).totalDebt;
                _loss = debt.sub(assets);
            }
        }

        return (_liquidatedAmount, _loss);
    }

	// call this if we need to immediately exit without harvesting
	// this will be fixed in the updated staking contract
	function emergencyWithdraw() external onlyAuthorized {
		sorbettiere.emergencyWithdraw();
	}

    function harvestTrigger(uint256 callCostinEth)
        public
        view
        override
        returns (bool)
    {
        StrategyParams memory params = vault.strategies(address(this));
        
        // have a manual toggle switch if needed since keep3rs are more efficient than manual harvest
        if (manualKeep3rHarvest == 1) return true;

        // Should not trigger if Strategy is not activated
        if (params.activation == 0) return false;

        // Should not trigger if we haven't waited long enough since previous harvest
        if (block.timestamp.sub(params.lastReport) < minReportDelay)
            return false;

        // Should trigger if hasn't been called in a while
        if (block.timestamp.sub(params.lastReport) >= maxReportDelay)
            return true;

        // If some amount is owed, pay it back
        // NOTE: Since debt is based on deposits, it makes sense to guard against large
        //       changes to the value from triggering a harvest directly through user
        //       behavior. This should ensure reasonable resistance to manipulation
        //       from user-initiated withdrawals as the outstanding debt fluctuates.
        uint256 outstanding = vault.debtOutstanding();
        if (outstanding > debtThreshold) return true;

        // Check for profits and losses
        uint256 total = estimatedTotalAssets();
        // Trigger if we have a loss to report
        if (total.add(debtThreshold) < params.totalDebt) return true;

        // no need to spend the gas to harvest every time; tend is much cheaper
        if (tendCounter < tendsPerHarvest) return false;
        
        // Trigger if it makes sense for the vault to send funds idle funds from the vault to the strategy, or to harvest.
        uint256 profit = 0;
        if (total > params.totalDebt) profit = total.sub(params.totalDebt); // We've earned a profit!
                
        // calculate how much the call costs in dollars (converted from ETH)
        uint256 callCost = ethToDollaBill(callCostinEth);
        
        // check if it's worth it to deposit funds from the vault to the strategy
        uint256 credit = vault.creditAvailable();
        return (profitFactor.mul(callCost) < credit.add(profit));
        
        // calculate how much profit we'll make if we harvest
        uint256 iceProfit = iceProfitIfSold();
        
        // check if we make enough from this to justify the harvest call
        return (harvestProfitFactor.mul(callCost) < iceProfit;
    }

    // convert our keeper's eth cost into dai
    function ethToDollaBill(uint256 _ethAmount) internal view returns (uint256) {
        address[] memory ethPath = new address[](2);
        ethPath[0] = address(weth);
        ethPath[1] = address(usdt);

        uint256[] memory callCostInUsdt = IUniswapV2Router02(uniswapRouter).getAmountsOut(_ethAmount, ethPath);
		
        return callCostInUsdt[1]; // this has 6 decimals
    	}

    // convert our unsold ICE into profit for our keep3r
    function iceProfitIfSold() internal view returns (uint256) {
    	uint256 totalIce = sorbettiere.pendingIce(pid, address(this)).add(ice.balanceOf(address(this)));
    
        address[] memory icePath = new address[](3);
        icePath[0] = address(ice);
        icePath[1] = address(weth);
        icePath[2] = address(usdt);
        
        uint256 _oneIce = 1e18;

        uint256[] memory iceSwap = IUniswapV2Router02(uniswapRouter).getAmountsOut(_oneIce, icePath);
		uint256 icePrice = iceSwap[2];
		
		uint256 iceProfitIfSold = icePrice.mul(totalIce)div(1e18);

        return iceProfitIfSold; // this has 6 decimals
    	}

    function prepareMigration(address _newStrategy) internal override {
        uint256 stakedTokens = sorbettiere.userInfo(pid, address(this)).amount;
        if (stakedTokens > 0) {
                sorbettiere.withdraw(pid, stakedTokens);
        }
    }


    function protectedTokens()
        internal
        view
        override
        returns (address[] memory)
    {}
    
	// Setter functions
    
	// set this to 1 if we want our keep3rs to manually harvest the strategy; keep3r harvest is more cost-efficient than strategist harvest
    function setKeep3rHarvest(uint256 _setKeep3rHarvest) external onlyAuthorized {
    	manualKeep3rHarvest = _setKeep3rHarvest;
    }
    
	// set this to the multiple we want to make on our harvests vs the cost
    function setharvestProfitFactor(uint256 _harvestProfitFactor) external onlyAuthorized {
    	harvestProfitFactor = _harvestProfitFactor;
    }

}
